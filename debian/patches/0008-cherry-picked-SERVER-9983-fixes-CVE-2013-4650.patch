From: Antonin Kral <a.kral@bobek.cz>
Date: Thu, 18 Jul 2013 15:46:22 +0200
Subject: cherry-picked SERVER-9983 fixes CVE-2013-4650

---
 jstests/auth/system_user_privileges.js      | 101 ++++++++++++++++++++++++++++
 src/mongo/db/auth/authorization_manager.cpp |  21 +++---
 2 files changed, 114 insertions(+), 8 deletions(-)
 create mode 100644 jstests/auth/system_user_privileges.js

diff --git a/jstests/auth/system_user_privileges.js b/jstests/auth/system_user_privileges.js
new file mode 100644
index 0000000..6d397e7
--- /dev/null
+++ b/jstests/auth/system_user_privileges.js
@@ -0,0 +1,101 @@
+/*
+ * Regression test for SECURITY-27.
+ *
+ * Verifies that creating a user named "__system" in any database does not get internal system
+ * privileges.
+ *
+ * Operates by creating an "admin" user for set-up, then creating __system users in the "test",
+ * "admin" and "local" databases.  Then, it verifies that the __system@local user is shadowed for
+ * password and privilege purposes by the keyfile.  It then procedes to verify that the
+ * __system@test and __system@admin users are _not_ shadowed in any way by the keyfile user.
+ */
+
+(function() {
+
+    "use strict";
+
+    // Runs the "count" command on a database in a way that returns the result document, for easier
+    // inspection of the errmsg.
+    function runCountCommand(conn, dbName, collectionName) {
+        return conn.getDB(dbName).runCommand({ count: collectionName });
+    }
+
+    // Asserts that on the given "conn", "dbName"."collectionName".count() fails as unauthorized.
+    function assertCountUnauthorized(conn, dbName, collectionName) {
+        assert.eq(runCountCommand(conn, dbName, collectionName).errmsg,
+                  "unauthorized",
+                  "On " + dbName + "." + collectionName);
+    }
+
+    var conn = MongoRunner.runMongod({ smallfiles: "", auth: "" });
+
+    var admin = conn.getDB('admin');
+    var test = conn.getDB('test');
+    var local = conn.getDB('local');
+
+    //
+    // Preliminary set up.
+    //
+    admin.addUser('admin', 'a');
+    admin.auth('admin', 'a');
+
+    //
+    // Add users named "__system" with no privileges on "test", "admin" and "local".  The one in
+    // "local" is shadowed by the keyfile.
+    //
+
+    test.addUser({user: '__system', pwd: 'a', roles: []});
+    admin.addUser({user: '__system', pwd: 'a', roles: []});
+    local.addUser({user: '__system', pwd: 'a', roles: []});
+
+    //
+    // Add some data to count.
+    //
+
+    admin.foo.insert({_id: 1});
+    test.foo.insert({_id: 2});
+    local.foo.insert({_id: 3});
+
+
+    admin.logout();
+    assertCountUnauthorized(conn, "admin", "foo");
+    assertCountUnauthorized(conn, "local", "foo");
+    assertCountUnauthorized(conn, "test", "foo");
+
+    //
+    // Validate that you cannot even log in as __system@local with the supplied password; you _must_
+    // use the password from the keyfile.
+    //
+    assert(!local.auth('__system', 'a'))
+    assertCountUnauthorized(conn, "admin", "foo");
+    assertCountUnauthorized(conn, "local", "foo");
+    assertCountUnauthorized(conn, "test", "foo");
+
+    //
+    // Validate that __system@test is not shadowed by the keyfile __system user.
+    //
+    test.auth('__system', 'a');
+    assertCountUnauthorized(conn, "admin", "foo");
+    assertCountUnauthorized(conn, "local", "foo");
+    assertCountUnauthorized(conn, "test", "foo");
+
+    test.logout();
+    assertCountUnauthorized(conn, "admin", "foo");
+    assertCountUnauthorized(conn, "local", "foo");
+    assertCountUnauthorized(conn, "test", "foo");
+
+    //
+    // Validate that __system@test is not shadowed by the keyfile __system user.
+    //
+    admin.auth('__system', 'a');
+    assertCountUnauthorized(conn, "admin", "foo");
+    assertCountUnauthorized(conn, "local", "foo");
+    assertCountUnauthorized(conn, "test", "foo");
+
+    admin.logout();
+    assertCountUnauthorized(conn, "admin", "foo");
+    assertCountUnauthorized(conn, "local", "foo");
+    assertCountUnauthorized(conn, "test", "foo");
+
+})();
+
diff --git a/src/mongo/db/auth/authorization_manager.cpp b/src/mongo/db/auth/authorization_manager.cpp
index ab2f5cd..74d0484 100644
--- a/src/mongo/db/auth/authorization_manager.cpp
+++ b/src/mongo/db/auth/authorization_manager.cpp
@@ -394,9 +394,21 @@ namespace {
         _authenticatedPrincipals.add(principal);
         if (!principal->isImplicitPrivilegeAcquisitionEnabled())
             return;
+
+        const std::string dbname = principal->getName().getDB().toString();
+        if (dbname == StringData("local", StringData::LiteralTag()) &&
+            principal->getName().getUser() == internalSecurity.user) {
+
+            // Grant full access to internal user
+            ActionSet allActions;
+            allActions.addAllActions();
+            acquirePrivilege(Privilege(PrivilegeSet::WILDCARD_RESOURCE, allActions),
+                             principal->getName());
+            return;
+        }
+
         _acquirePrivilegesForPrincipalFromDatabase(ADMIN_DBNAME, principal->getName());
         principal->markDatabaseAsProbed(ADMIN_DBNAME);
-        const std::string dbname = principal->getName().getDB().toString();
         _acquirePrivilegesForPrincipalFromDatabase(dbname, principal->getName());
         principal->markDatabaseAsProbed(dbname);
     }
@@ -491,13 +503,6 @@ namespace {
                                   << principal.getDB(),
                           0);
         }
-        if (principal.getUser() == internalSecurity.user) {
-            // Grant full access to internal user
-            ActionSet allActions;
-            allActions.addAllActions();
-            return acquirePrivilege(Privilege(PrivilegeSet::WILDCARD_RESOURCE, allActions),
-                                    principal);
-        }
         return buildPrivilegeSet(dbname, principal, privilegeDocument, &_acquiredPrivileges);
     }
 
